options {
    MULTI=true;
    STATIC=false;
    VISITOR=true;
//    VISITOR_RETURN_TYPE="VisitorData";
    VISITOR_DATA_TYPE="VisitorData";
    NODE_DEFAULT_VOID=true;
//    DEBUG_PARSER = true;
}

PARSER_BEGIN(FilterParser)
package com.nccgroup.loggerplusplus.filter.parser;
import com.nccgroup.loggerplusplus.filter.Operator;
import com.nccgroup.loggerplusplus.filter.BooleanOperator;
import com.nccgroup.loggerplusplus.filterlibrary.FilterLibraryController;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.regex.Pattern;
import java.util.HashMap;
import java.util.HashSet;
import java.math.BigDecimal;

public class FilterParser {

    public static ASTExpression parseFilter(String string) throws IOException, ParseException {
        FilterParser FilterParser = new FilterParser(new StringReader(string));
        ASTExpression node;
        try{
            node = FilterParser.Filter();
        }catch(Exception e){
            throw new ParseException(e.getMessage());
        }
        VisitorData result = new SanityCheckVisitor().visit(node);
        if(!result.isSuccess()) throw new ParseException(result.getErrorString());
        return node;
    }

    public static void checkAliasesForSanity(FilterLibraryController libraryController, ASTExpression filter) throws ParseException {
        VisitorData result = new AliasCheckVisitor(libraryController).visit(filter);
        if(!result.isSuccess()) throw new ParseException(result.getErrorString());
    }
}

PARSER_END(FilterParser)

SKIP:  { " " }
TOKEN [IGNORE_CASE]: {
    <EQ: "=" | "==" >
    | <NEQ: "!=" >
    | <GT: ">" >
    | <LT: "<" >
    | <GEQ: ">=" >
    | <LEQ: "<=" >
    | <OR: "|" | "||" | "OR" >
    | <AND: "&" | "&&" | "AND" >
    | <XOR: "^" | "XOR" >
    | <CONTAINS: "CONTAINS" >
    | <IN: "IN" >
    | <BOOLEAN: "TRUE" | "FALSE">
    | <SINGLEQUOTEDSTRING: "'" ("\\" ~[] | ~["\'", "\\"])* "'" >
    | <DOUBLEQUOTEDSTRING: "\"" ("\\" ~[] | ~["\"", "\\"])* "\"" >
    | <NUMBER: ("-"|"+")?(<DIGIT>)+("."(<DIGIT>)+)?>
    | <DIGIT: ["0"-"9"] >
    | <REGEXLITERAL_IN_FORWARD_SLASHES: "/\\Q" ("\\" ~["E"] | ~["\\"])* "\\E/" >
    | <REGEX_IN_FORWARD_SLASHES: "/" ("\\" ~[] | ~["/", "\\"])+ "/" >
    | <MATCHES: "MATCHES" >
    | <LPAREN: "(" >
    | <RPAREN: ")" >
    | <INVERSE: "!" | "NOT" >
    | <DOT: "." >
    | <IDENTIFIER: (["a"-"z","A"-"Z","_","0"-"9"])+ >
    | <ARRAY_START: "[" >
    | <ARRAY_END: "]" >
    | <ARRAY_SEPARATOR: ",">
    | <ALIAS_SYMBOL: "#">
}



ASTExpression Filter() #Expression :
{
 Boolean inverse=false;
 BooleanOperator op = null;
}
{
//    (LOOKAHEAD(2) [inverse=Inverse()] <LPAREN> ExpressionInner() [(op=And() ExpressionInner())+ | (op=Or() ExpressionInner())+ | (op=Xor() ExpressionInner())+] <RPAREN>
//    | ExpressionInner() [(op=And() ExpressionInner())+ | (op=Or() ExpressionInner())+ | (op=Xor() ExpressionInner())+])
    ExpressionInner() [(op=And() ExpressionInner())+ | (op=Or() ExpressionInner())+ | (op=Xor() ExpressionInner())+]

    <EOF>
    {
        jjtThis.op = op;
        jjtThis.inverse = inverse;
        return jjtThis;
    }
}

ASTExpression Expression() #Expression :
{
 Boolean inverse = null;
 BooleanOperator op = null;
}
{
    //Recursive to handle brackets nicely - optional invertor
    (LOOKAHEAD(2) [inverse=Inverse()] <LPAREN> ExpressionInner() [(op=And() ExpressionInner())+ | (op=Or() ExpressionInner())+ | (op=Xor() ExpressionInner())+] <RPAREN>
    | Comparison())

    {
        jjtThis.op = op;
        jjtThis.inverse = inverse != null;
        return jjtThis;
    }
}

void ExpressionInner() #void :
{}
{
    (LOOKAHEAD(3) Comparison() | Alias() | Expression())
}


//Comparisons can take two forms (Value) or (value operation value).
//To make interpretation easier, we convert (Value) to (Value operation value) by means of (Value EQUALS TRUE)
ASTComparison Comparison() #Comparison:
{
 Operator op;
 Object left, right;
 Boolean value;
}
{
    left = Value()
    {
        jjtThis.left = left;
    }

    (op = Operator() right = Value() //Basic Operators With Right Value
        {
            jjtThis.right = right;
            jjtThis.operator = op;
        }
    | op = InOperator() right = Array()
        {
            jjtThis.right = right;
            jjtThis.operator = op;
        }
    | op = MatchesOperator() (right = RegexInString() | right = RegexInForwardSlashes())
        {
            jjtThis.right = right;
            jjtThis.operator = op;
        }
    | //NO OPERATOR OR RIGHT VALUE (EQ TRUE)
        {
            jjtThis.operator = Operator.EQUAL;
            jjtThis.right = true;
        }
    )
    {return jjtThis;}
}

ASTAlias Alias() #Alias:
{
    Token identifier;
}
{
    <ALIAS_SYMBOL> identifier=<IDENTIFIER>
    {
        jjtThis.identifier = identifier.image;
        return jjtThis;
    }
}

Object Value() #void:
{
    Object v;
}
{
    (LOOKAHEAD(2) v = Identifier() | v = Number() | v = Boolean() | LOOKAHEAD(2) v = String() | v = RegexInForwardSlashes() | v = RegexInString())
    {return v;}
}

HashSet Array() #void:
{
    HashSet<Object> items = new HashSet();
    Object i;
}{
    <ARRAY_START>
    (
        LOOKAHEAD(2) i=String() {items.add(i);} (<ARRAY_SEPARATOR> i=String() {items.add(i);})* //String array
    |
        LOOKAHEAD(2) i=Number() {items.add(i);} (<ARRAY_SEPARATOR> i=Number() {items.add(i);})* //Number array
    )
    <ARRAY_END>

    { return items; }
}

//IDENTIFIERS
ASTIdentifier Identifier() #Identifier:
{
    Token group, identifier, inverse = null;
}
{
    [inverse=<INVERSE>] group=<IDENTIFIER> <DOT> identifier=<IDENTIFIER>
    {
        jjtThis.inverse = inverse != null;
        jjtThis.group = group.image;
        jjtThis.field = identifier.image;
        return jjtThis;
    }
}

//END IDENTIFIERS


//TYPES

BigDecimal Number() #void :
{Token t;}
{
    t=<NUMBER>
    {return new BigDecimal(t.image);}
}

String String() #void :
{Token t;}
{
    ( t=<SINGLEQUOTEDSTRING> | t=<DOUBLEQUOTEDSTRING> )

    {
        String s = t.image.substring(1,t.image.length()-1);
        return org.apache.commons.text.StringEscapeUtils.unescapeJava(s);
    }
}

Pattern RegexInString() #void :
{Token t;}
{
    ( t=<DOUBLEQUOTEDSTRING> | t=<SINGLEQUOTEDSTRING> )
    {
        return Pattern.compile(t.image.substring(1,t.image.length()-1), Pattern.CASE_INSENSITIVE);
    }
}

Pattern RegexInForwardSlashes() #void :
{Token t;}
{
    ( t=<REGEXLITERAL_IN_FORWARD_SLASHES> | t=<REGEX_IN_FORWARD_SLASHES> )
    {
        return Pattern.compile(t.image.substring(1,t.image.length()-1), Pattern.CASE_INSENSITIVE);
    }
}

Boolean Boolean() #void :
{Token t, inverse=null;}
{
    [inverse=<INVERSE>]
    t=<BOOLEAN>
    {
        return (inverse != null ^ Boolean.parseBoolean(t.image));
    }
}

//END TYPES


//BASIC OPERATORS

Operator Operator() #void :
{}
{
      <EQ>  {return Operator.EQUAL;}
    | <NEQ> {return Operator.NOT_EQUAL;}
    | <GT>  {return Operator.GREATER_THAN;}
    | <LT>  {return Operator.LESS_THAN;}
    | <GEQ> {return Operator.GREATER_THAN_EQUAL;}
    | <LEQ> {return Operator.LESS_THAN_EQUAL;}
    | <CONTAINS> {return Operator.CONTAINS;}
}

Operator MatchesOperator() #void :
{}
{
    <MATCHES> {return Operator.MATCHES;}
}

Operator InOperator() #void :
{}
{
    <IN> {return Operator.IN;}
}

boolean Inverse() #void :
{}
{
    <INVERSE> {return true;}
}

BooleanOperator And() #void :
{}
{
    <AND> {return BooleanOperator.AND;}
}

BooleanOperator Or() #void :
{}
{
    <OR> {return BooleanOperator.OR;}
}

BooleanOperator Xor() #void :
{}
{
    <XOR> {return BooleanOperator.XOR;}
}